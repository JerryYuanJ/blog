import{_ as a,c as o,o as t,ae as i}from"./chunks/framework.CLNW5JS9.js";const r="/blog/assets/101_seq.Hfvy5iY2.svg",d="/blog/assets/101.CCvUAFJZ.png",s="/blog/assets/502.DpmgzH_A.png",m=JSON.parse('{"title":"Status Code","description":"","frontmatter":{},"headers":[],"relativePath":"docs/http/status-code.md","filePath":"docs/http/status-code.md"}'),l={name:"docs/http/status-code.md"};function n(c,e,h,p,u,k){return t(),o("div",null,e[0]||(e[0]=[i('<h1 id="status-code" tabindex="-1">Status Code <a class="header-anchor" href="#status-code" aria-label="Permalink to &quot;Status Code&quot;">​</a></h1><p>HTTP状态码，是响应报文中起始行的一部分，它是对响应结果的一种说明，通过它，我们很容易的就知道一个请求是否成功的完成了。状态码由三位数字构成，第一位表示着响应的类别，一共有五种类型：</p><ol><li><code>1XX（Informational）</code>信息类状态码</li><li><code>2XX（Successful）</code>成功状态码</li><li><code>3XX（Redirection）</code>重定向状态码</li><li><code>4XX（Client Error）</code>客户端错误状态码</li><li><code>5XX（Server Error）</code>服务端错误状态码</li></ol><p>状态码一般都伴随着一个<strong>原因短语</strong>，比如<code>404</code>对应<code>Not Found</code>，<code>200</code>对应<code>Ok</code>等，原因短语是对请求结果的更加语义化的描述。 随着HTTP的发展，状态码变得越来越多，虽然我们不需要全部都了解，但是对于一些常见的状态码，还是要能够知道它的含义。接下来我们就来看看常见的各个类别的状态码。</p><h2 id="_1xx-信息类状态码" tabindex="-1">1XX：信息类状态码 <a class="header-anchor" href="#_1xx-信息类状态码" aria-label="Permalink to &quot;1XX：信息类状态码&quot;">​</a></h2><h3 id="_101-switching-protocols" tabindex="-1">101 Switching Protocols <a class="header-anchor" href="#_101-switching-protocols" aria-label="Permalink to &quot;101 Switching Protocols&quot;">​</a></h3><p><code>101</code>状态码表示服务器针对客户端升级协议的请求对协议进行切换。一般经历的步骤如下：</p><p><img src="'+r+`" alt="101切换协议时序图"></p><p><em>图片来源于<a href="https://juejin.im/post/5d9c6c19e51d4578377fe4d8" target="_blank" rel="noreferrer">掘金</a></em></p><ol><li>客户端发起升级协议的请求，这个请求包含两个首部字段：</li></ol><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Upgrade</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Upgrade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">协议名</span></span></code></pre></div><ol start="2"><li>服务器检查是否支持客户端所要求的协议</li><li>如果支持的话，会发送一个状态码为<code>101 Switching Protocols</code>的响应，并且加上客户端请求的<code>Connection</code>和<code>Upgrade</code>的首部</li><li>客户端与服务端以新的协议进行数据的传输</li></ol><p>可以看一个实际的例子：</p><img src="`+d+`" alt="101状态码示例图" width="70%"><h2 id="_2xx-成功状态码" tabindex="-1">2XX：成功状态码 <a class="header-anchor" href="#_2xx-成功状态码" aria-label="Permalink to &quot;2XX：成功状态码&quot;">​</a></h2><h3 id="_200-ok" tabindex="-1">200 OK <a class="header-anchor" href="#_200-ok" aria-label="Permalink to &quot;200 OK&quot;">​</a></h3><p>这应该是最常见的状态码了，它表示请求成功。这个“成功”的含义取决于具体的HTTP方法，例如，如果是<code>GET</code>方法，那么就表示资源已经在响应正文中被返回；如果是<code>HEAD</code>方法，那么就表示实体的首部信息已经在响应体中返回了。</p><h3 id="_201-created" tabindex="-1">201 Created <a class="header-anchor" href="#_201-created" aria-label="Permalink to &quot;201 Created&quot;">​</a></h3><p>表示请求成功，并且新创建了一个资源。比如用户注册，就有可能会在服务器中新建一条用户记录，这时候就可以返回<code>201</code>表示用户成功创建。</p><h3 id="_204-no-content" tabindex="-1">204 No Content <a class="header-anchor" href="#_204-no-content" aria-label="Permalink to &quot;204 No Content&quot;">​</a></h3><p>表示请求成功，但是没有返回内容。这里的<code>No Content</code>指的是响应报文中的内容主体部分，这个状态码的使用场景，一般是只需要客户端发送信息到服务端，而不需要服务端发送信息到客户端。但是在某些情况下，响应中的首部信息会包含一些有用的信息，客户端会根据这个最新的首部信息进行相应的更新。</p><h3 id="_206-partial-content" tabindex="-1">206 Partial Content <a class="header-anchor" href="#_206-partial-content" aria-label="Permalink to &quot;206 Partial Content&quot;">​</a></h3><p>当请求报文的首部字段中包含<code>Range</code>时，表示这一个请求是部分资源请求，即只请求资源的指定字节范围的内容，这时候应该响应<code>206</code>，表示这个部分资源请求已经成功了，返回的内容正式请求的那一个字节范围的资源。</p><h2 id="_3xx-重定向状态码" tabindex="-1">3XX：重定向状态码 <a class="header-anchor" href="#_3xx-重定向状态码" aria-label="Permalink to &quot;3XX：重定向状态码&quot;">​</a></h2><h3 id="_301-move-permanently" tabindex="-1">301 Move Permanently <a class="header-anchor" href="#_301-move-permanently" aria-label="Permalink to &quot;301 Move Permanently&quot;">​</a></h3><p>一般我们将<code>301</code>状态码的作用称之为<strong>永久重定向</strong>。它表示我们当前所请求的资源，已经被分配了新的URL，以后应该使用这个新的URL来访问这个资源。这个新的URL，会在响应首部的<code>Location</code>字段中给出。一般流程如下：</p><ol><li>客户端请求资源</li></ol><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">GET /index.html HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">www.test.com</span></span></code></pre></div><ol start="2"><li>服务器接收到请求后，发现这个资源已经被移到另一个地方去了，并且以后都不会变，所以返回的response为：</li></ol><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">HTTP/1.1 301 Move Permanently</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">http://www.test.com/main.html</span></span></code></pre></div><ol start="3"><li>浏览器接收到这个响应后，会自动重定到<code>Location</code>指定的地址，并且会记住这个原始的URL的重定向的地址，<strong>下次如果再次访问原始URL的话，不会向服务器发送<code>GET /index.html</code>的请求，而是直接请求<code>main.html</code>页面</strong>。</li></ol><h3 id="_302-found" tabindex="-1">302 Found <a class="header-anchor" href="#_302-found" aria-label="Permalink to &quot;302 Found&quot;">​</a></h3><p>跟<code>301</code>对应的，我们一般称<code>302</code>为临时重定向。它表示请求的资源已经被分配了新的URL，希望用户本次能使用新的URL访问。与<code>301</code>不同的是，它表示资源只是临时性的被移到了新的地址。也就是说，这个地址以后还可能会变。比如用户访问a页面时，服务器用<code>302</code>状态码让它重定向到b页面，但是浏览器这时候不会记住这次重定向的信息，下次再访问a页面时，还是会向a页面发出请求，然后再由服务器决定重定向的地址。</p><h3 id="_303-see-other" tabindex="-1">303 See Other <a class="header-anchor" href="#_303-see-other" aria-label="Permalink to &quot;303 See Other&quot;">​</a></h3><p><code>303</code>状态码表示由于请求对应的资源存在着另一个URI，应使用<code>GET</code>方法定向获取请求的资源。它与<code>302</code>状态码有着相同的功能，但是<strong>它明确的表明应该使用<code>GET</code>方法去获取资源</strong>。</p><h3 id="_304-not-modified" tabindex="-1">304 Not Modified <a class="header-anchor" href="#_304-not-modified" aria-label="Permalink to &quot;304 Not Modified&quot;">​</a></h3><p><code>304</code>是一个很有趣的状态码，虽然它是以3开头，但是却与重定向没有没有任何关系。这是一个与缓存相关的头，它告诉客户端，响应的资源没有被修改过，客户端可以继续使用这个响应的本地缓存。<strong>注意，<code>304</code>状态码返回时，不包含任何响应的主体部分。</strong> 我们会在<a href="./cache.html">HTTP缓存</a>一章中进一步的认识这个状态码的作用。</p><h3 id="_307-temporary-redirect" tabindex="-1">307 Temporary Redirect <a class="header-anchor" href="#_307-temporary-redirect" aria-label="Permalink to &quot;307 Temporary Redirect&quot;">​</a></h3><p>临时重定向。这个状态码与<code>302</code>语义一致，唯一的区别就是客户端不能改变请求的方法：比如第一次是用<code>POST</code>请求某一个资源的，在第二次请求，也就是重定向到<code>Location</code>的地址时，也必须使用<code>POST</code>方法。</p><h3 id="_308-permanent-redirect" tabindex="-1">308 Permanent Redirect <a class="header-anchor" href="#_308-permanent-redirect" aria-label="Permalink to &quot;308 Permanent Redirect&quot;">​</a></h3><p>永久重定向。这个状态码与<code>301</code>语义一致，区别和上面的<code>307</code>与<code>302</code>的区别一样，即客户端不能改变请求的方法。</p><h2 id="_4xx-客户端错误状态码" tabindex="-1">4XX：客户端错误状态码 <a class="header-anchor" href="#_4xx-客户端错误状态码" aria-label="Permalink to &quot;4XX：客户端错误状态码&quot;">​</a></h2><h3 id="_400-bad-request" tabindex="-1">400 Bad Request <a class="header-anchor" href="#_400-bad-request" aria-label="Permalink to &quot;400 Bad Request&quot;">​</a></h3><p>这个状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p><h3 id="_401-unauthorized" tabindex="-1">401 Unauthorized <a class="header-anchor" href="#_401-unauthorized" aria-label="Permalink to &quot;401 Unauthorized&quot;">​</a></h3><p>表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。若之前已经进行过一次请求，则表示用户认证失败。它就好像服务器说：“你未经授权，或者授权不正确。请授权后重试。” 对应的，服务器会返回<code>WWW-Authenticate</code>首部字段来告诉客户端如何认证。</p><h3 id="_403-forbidden" tabindex="-1">403 Forbidden <a class="header-anchor" href="#_403-forbidden" aria-label="Permalink to &quot;403 Forbidden&quot;">​</a></h3><p>表示对请求资源的访问被服务器拒绝了。它与<code>401</code>的不同是，服务器知道你的身份，但是你没有响应的权限去访问这个资源。它就像服务器说：“对不起，我知道你是谁，但是你无权访问这个资源。你可以联系管理员去给你授权，在那之前还请你不要再来访问了。” 这个状态码一般是与业务逻辑紧密相关的。</p><h3 id="_404-not-found" tabindex="-1">404 Not Found <a class="header-anchor" href="#_404-not-found" aria-label="Permalink to &quot;404 Not Found&quot;">​</a></h3><p>这应该是最常见的状态码之一，它表示我们请求的资源服务器没有找到。</p><h3 id="_405-method-not-allowed" tabindex="-1">405 Method Not Allowed <a class="header-anchor" href="#_405-method-not-allowed" aria-label="Permalink to &quot;405 Method Not Allowed&quot;">​</a></h3><p>该状态码表示对于当前的请求，<strong>服务器知道该请求方法，但目标资源不支持该请求方法</strong>。服务器需要生成一个<code>Allow</code>的首部字段，它包含着目标资源支持的方法。比如当使用<code>DELETE</code>去发送一个删除某资源的请求，但是该资源不支持<code>DELETE</code>方法时，可能会得到如下的响应结果：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">405 Method Not Allowed</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Allow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">GET, POST, HEAD</span></span></code></pre></div><h2 id="_5xx-服务端错误状态码" tabindex="-1">5XX：服务端错误状态码 <a class="header-anchor" href="#_5xx-服务端错误状态码" aria-label="Permalink to &quot;5XX：服务端错误状态码&quot;">​</a></h2><h3 id="_500-internal-server-error" tabindex="-1">500 Internal Server Error <a class="header-anchor" href="#_500-internal-server-error" aria-label="Permalink to &quot;500 Internal Server Error&quot;">​</a></h3><p>一般服务器出错都会报这个错，表示服务器内部出现了问题。</p><h3 id="_502-bad-gateway" tabindex="-1">502 Bad Gateway <a class="header-anchor" href="#_502-bad-gateway" aria-label="Permalink to &quot;502 Bad Gateway&quot;">​</a></h3><p>当服务器作为网关或者代理的时候，接收到请求时，上游服务器返回的响应出错导致了这次请求的失败。我们一般会在<code>Nginx</code>的错误页面看到这样的信息：</p><p><img src="`+s+'" alt="502-bad-gateway"></p><p>关于更多<code>502</code>状态码的介绍，可以参考这篇文章：<a href="https://www.wpoven.com/blog/need-know-502-error-bad-gateway/" target="_blank" rel="noreferrer">https://www.wpoven.com/blog/need-know-502-error-bad-gateway/</a></p><h3 id="_503-service-unavailable" tabindex="-1">503 Service Unavailable <a class="header-anchor" href="#_503-service-unavailable" aria-label="Permalink to &quot;503 Service Unavailable&quot;">​</a></h3><p><code>503</code>表示着当前服务器不具备处理请求的能力，这可能有多种原因，比如服务器在维护，或者服务器超负荷了等等。如果发生了这样的情况，最好在响应中加上<code>Retry-After</code>的首部字段，告诉用户多长时间后系统恢复正常。</p><h3 id="_504-gateway-timeout" tabindex="-1">504 Gateway Timeout <a class="header-anchor" href="#_504-gateway-timeout" aria-label="Permalink to &quot;504 Gateway Timeout&quot;">​</a></h3><p>当服务器作为网关或者代理的时候，接收到请求时，没有及时的收到上游服务器的响应导致了这次请求的失败。</p><hr><p>最后关于状态码，我们要知道的是，这些状态码并非是强约束，服务器完全可以不按照这种方式来返回。比如服务器内部错误，可以返回<code>200</code>，并且将服务器错误的信息作为返回结果给客户端，这些都是可以的。</p><h3 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></li><li><a href="https://tools.ietf.org/html/rfc7231#section-6" target="_blank" rel="noreferrer">https://tools.ietf.org/html/rfc7231#section-6</a></li></ul>',68)]))}const g=a(l,[["render",n]]);export{m as __pageData,g as default};
