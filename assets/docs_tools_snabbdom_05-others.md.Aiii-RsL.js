import{_ as a,c as o,o as t,ae as d}from"./chunks/framework.CLNW5JS9.js";const m=JSON.parse('{"title":"Q&A","description":"","frontmatter":{},"headers":[],"relativePath":"docs/tools/snabbdom/05-others.md","filePath":"docs/tools/snabbdom/05-others.md"}'),r={name:"docs/tools/snabbdom/05-others.md"};function n(s,e,i,c,l,h){return t(),o("div",null,e[0]||(e[0]=[d('<h1 id="q-a" tabindex="-1">Q&amp;A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q&amp;A&quot;">​</a></h1><p>前面几个章节，我们基本上学完了 snabbdom 的原理，包括 vnode，patch，modules，thunks 等相关的介绍，但是 snabbdom 还有一些其它重要的逻辑我们介绍主流程的时候忽略了，这里我们补充介绍以下三点：</p><ul><li><code>diff</code>：当新旧节点都包含 children 时，snabbdom 是如何比对的？</li><li><code>createRmCb</code>：为什么在移除节点时需要用这个函数来包一层？</li><li><code>insertedVnodeQueue</code>：多次出现的 insertedVnodeQueue 到底有啥用？</li></ul><p>带着这三个问题，我们来看源码。</p><h2 id="diff" tabindex="-1">diff <a class="header-anchor" href="#diff" aria-label="Permalink to &quot;diff&quot;">​</a></h2><h2 id="creatermcb" tabindex="-1">createRmCb <a class="header-anchor" href="#creatermcb" aria-label="Permalink to &quot;createRmCb&quot;">​</a></h2><h2 id="insertedvnodequeue" tabindex="-1">insertedVnodeQueue <a class="header-anchor" href="#insertedvnodequeue" aria-label="Permalink to &quot;insertedVnodeQueue&quot;">​</a></h2>',7)]))}const b=a(r,[["render",n]]);export{m as __pageData,b as default};
