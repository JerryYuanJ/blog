import{_ as i,c as a,o as n,ae as e}from"./chunks/framework.CLNW5JS9.js";const l="/blog/assets/code-sleep-1.Ct_4ZvFN.gif",h="/blog/assets/code-sleep-2.C5BSVlDX.gif",p="/blog/assets/code-sleep.98BZjOSN.gif",y=JSON.parse('{"title":"JS 实现 Sleep 功能","description":"","frontmatter":{},"headers":[],"relativePath":"docs/basic/js/sleep.md","filePath":"docs/basic/js/sleep.md"}'),t={name:"docs/basic/js/sleep.md"};function k(d,s,E,o,r,c){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="js-实现-sleep-功能" tabindex="-1">JS 实现 Sleep 功能 <a class="header-anchor" href="#js-实现-sleep-功能" aria-label="Permalink to &quot;JS 实现 Sleep 功能&quot;">​</a></h1><p>这其实是一个很有意思的题目，因为像一些编程语言中提供了类似休眠的方法，比如<code>java</code>的<code>Thread.sleep(3000)</code>，就是休息3秒。在js中虽然没有直接提供，但是我们可以通过一些<code>hack</code>的手段来实现这个有趣的功能。</p><h2 id="暴力版" tabindex="-1">暴力版 <a class="header-anchor" href="#暴力版" aria-label="Permalink to &quot;暴力版&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ms; ){}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>先来看一下效果</p><p><img src="`+l+`" alt="sleep"></p><p>我们来分析一下代码，它的机制就是来一段循环，但是这个循环条件是跟我们的当前时间有关的。我们一开始定义了一个当前时间<code>now</code>，接着判断最新的时间<code>Date.now()</code>与之前的时间的大小，如果小于休眠时间的话，继续循环，直到大于休眠时间为止才不循环了。</p><p>说实话，这个想法很巧妙，但是呢，实现的效果却很不好，因为大量的循环会让一些浏览器“卡死”。我们在这段循环中加入一个计数器，看看到底循环了多少次：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ms; ){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>执行结果：</p><p><img src="`+h+`" alt="sleep"></p><p><strong>震惊！竟然有3万多次！所以这个方法千万不要在生产环境用！</strong></p><h2 id="优雅版-🌟" tabindex="-1">优雅版 🌟 <a class="header-anchor" href="#优雅版-🌟" aria-label="Permalink to &quot;优雅版 🌟&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, ms))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>我们在Chrome上看看结果：</p><p><img src="`+p+'" alt="sleep"></p><p>简单分析一下代码，我们执行<code>await sleep(30000)</code>时，会去执行<code>sleep</code>方法，我们知道，<code>await</code>跟的是一个<code>Promise</code>并且这个<code>Promise</code>是<code>pending</code>状态的话，那么<code>await</code>后面的代码都不会执行，所以就相当于休眠了。而我们的<code>sleep</code>函数中，返回的<code>Promise</code>，会在<code>3000ms</code>，也就是指定的睡眠时间之后被<code>resolve</code>，所以三秒后<code>await</code>后面的<code>Promise</code>状态改变，就继续往下执行了，打印<code>hello</code>。</p><p>由于这种方式几乎没有什么副作用，而且长得也好看，所以是目前的最佳方案。</p><h2 id="ajax-版" tabindex="-1">AJAX 版 <a class="header-anchor" href="#ajax-版" aria-label="Permalink to &quot;AJAX 版&quot;">​</a></h2><p>这个方法我也是看别人想到的，觉得真的跟脑筋急转弯一样的。我们知道<code>XHR</code>对象发出的请求，可以支持同步，比如：<code>xhr.open(&#39;GET&#39;, &#39;/&#39;, false)</code>，也就是我发完了请求后啥也不做，就等请求回来我再干其他的。基于这个思路，我们也很容易的实现这种<code>sleep</code>的功能。利用网络的延迟来实现休眠的功能也是一个思路，但是 它有两个缺点：</p><ol><li>无法设置固定的超时时长（<code>timeout</code>属性是不可以设置在同步请求上的）</li><li>对服务器的压力大，并且如果你频繁调用这种无谓请求的话，本身也是一种资源的浪费</li></ol>',21)]))}const F=i(t,[["render",k]]);export{y as __pageData,F as default};
