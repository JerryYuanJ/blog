import{_ as t,c as o,o as i,ae as s}from"./chunks/framework.CLNW5JS9.js";const a="/blog/assets/cookie.CfJWSNFX.png",g=JSON.parse('{"title":"Cookie","description":"","frontmatter":{},"headers":[],"relativePath":"docs/http/cookie.md","filePath":"docs/http/cookie.md"}'),l={name:"docs/http/cookie.md"};function d(c,e,n,r,p,k){return i(),o("div",null,e[0]||(e[0]=[s('<h1 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h1><h2 id="什么是cookie" tabindex="-1">什么是Cookie <a class="header-anchor" href="#什么是cookie" aria-label="Permalink to &quot;什么是Cookie&quot;">​</a></h2><p>我们知道，HTTP是无状态的协议，也就是说，如果你在访问某个网站，单从HTTP协议的角度来说，网站的服务器是不知道你的上一次请求情况的。但是我们很多场景都需要我们的服务器记住用户之前的某些操作，举个很常见的例子，当我们登陆淘宝时，浏览不同的页面，淘宝不会让我们重复的登陆，这就说明它记录下了我们的登陆状态。实现这个功能有很多种方式，其中一种就是<strong>Cookie</strong>机制。</p><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的<strong>一小块数据</strong>，它会在浏览器下次再次发送请求时，<strong>满足条件的情况下</strong>，随着请求报文一并发送到服务器上。<strong>Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</strong></p><h2 id="cookie的简单使用" tabindex="-1">Cookie的简单使用 <a class="header-anchor" href="#cookie的简单使用" aria-label="Permalink to &quot;Cookie的简单使用&quot;">​</a></h2><p>服务器会在响应头部<strong>Set-Cookie</strong>中设置相应的Cookie值，比如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sid=123456</span></span></code></pre></div><p>上面的头部就会设置一个名称为<code>sid</code>，值为<code>123456</code>的Cookie值到我们的浏览器上。浏览器在下一次往相同服务器发送请求时，会在<code>Cookie</code>的请求头部上带上这个信息：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sid=123456</span></span></code></pre></div><p>同时，你可以通过js来获取这个cookie的值：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.cookie </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 sid=123456</span></span></code></pre></div><p>我们也可以通过Chrome DevTools中的Application面板看到网站的cookies，例如github的网站上的cookies如图所示：</p><p><img src="'+a+`" alt="Cookies"></p><h2 id="cookie详解" tabindex="-1">Cookie详解 <a class="header-anchor" href="#cookie详解" aria-label="Permalink to &quot;Cookie详解&quot;">​</a></h2><p>关于Cookie，除了名称和值这两个字段外，它有如下几个比较重要的标记信息：</p><ol><li><strong>过期时间：<code>Expire/Max-Age</code></strong></li></ol><p>根据Cookie是否携带过期时间，我们通常将Cookie分为两类：<strong>会话期Cookie</strong>和<strong>持久性Cookie</strong>。会话期Cookie的生命周期仅存于会话期，即关闭网页或者浏览器，这个Cookie就会被删除；而持久性Cookie则会在到期之前一直有效，不论浏览器是否关闭，<strong>它的时间是相对于客户端而言的</strong>。</p><p><code>Expire</code>和<code>Max-Age</code>都是用来表示过期时间的，不同的是，<code>Expires</code>的值是一个具体的日期值，它表示该Cookie在该日期之前都有效；<code>Max-Age</code>的值是一个数字，它表示经过多少<strong>秒</strong>这个cookie会失效，这个属性在一些老的浏览器不支持。如果<code>Expires</code>和<code>Max-Age</code>都存在，并且在浏览器都支持的情况下，<code>Max-Age</code>的优先级要高。例如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">id=12; Expires=Wed, 21 Jan 2020 07:28:00 GMT</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">id=123; Max-Age=10000</span></span></code></pre></div><p>上面设置了名为<code>id</code>的cookie，它设置的失效时间<code>Expires</code>为2020年1月21日07:28:00，生效时长<code>Max-Age</code>为10秒，假设浏览器对于这两个属性都支持的话，那么<code>Max-Age</code>的值将会被采用，也就是说，这个cookie将会在10秒后失效。</p><p><strong>如果要手动的删除某个某个cookie的值，可以将它的Expires属性设置为一个过去的时间点，或者Max-Age属性设置为0或-1。</strong></p><ol start="2"><li><strong>Secure</strong></li></ol><p>设置为<code>Secure</code>的Cookie，只会在<strong>https</strong>的环境下被发送给服务端。但是要注意的是，即使在https环境下，敏感信息也<strong>不应该</strong>通过Cookie传输。</p><ol start="3"><li><strong>HttpOnly</strong></li></ol><p>我们知道，JavaScript的API<code>document.cookie</code>可以获取当前网站下的cookie。如果你不想让js来获取某一个cookie值时，给这个cookie加上<code>HttpOnly</code>的标记即可，例如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">id=1; Secure; HttpOnly;</span></span></code></pre></div><p>这个名称为<code>id</code>的cookie，通过js是获取不到的。</p><ol start="4"><li><strong>Domain</strong></li></ol><p>指定Cookie对于哪个域是有效的。如果没有指定的话，默认值就是当前网页的URL（不包含子域）；反之如果指定的话，那么各个子域也包含这个Cookie。比如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sid=123; Domain=test.com</span></span></code></pre></div><p>上例设置了一个名称为<code>sid</code>的cookie，它对于域名为<code>test.com</code>的域都是有效的，当然也包括它的子域，即我们在<code>a.test.com</code>或者<code>b.test.com</code>中，都可以访问到这个cookie。</p><ol start="5"><li><strong>Path</strong></li></ol><p>指定对于域中的某一路径，在这个路径下才会向服务器发送cookie。例如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sid=123; Path=/test; Domain=www.test.com</span></span></code></pre></div><p>这里例子中，我们设置了名为<code>sid</code>的cookie，它会在域名为<code>www.test.com</code>，路径为<code>/test</code>的url下才会生效，比如我们请求一个资源，它的路径为<code>http://www.test.com/test</code>或者子路径<code>http://www.test.com/test/images/1.png</code>，那么这个cookie就会被发送。</p><ol start="6"><li><strong>SameSite</strong></li></ol><p>这个属性早在Chrome51的时候就被引入了，它的初衷是为了阻止CSRF攻击。<code>SameSite</code>的值可以为下面的三个之一：</p><ol><li>Strict</li></ol><p>这是要求最严格的，完全禁止第三方Cookie，只有当前网页URL与请求目标一致，才会发送Cookie。这个属性带来的用户体验非常不好，举个例子，你登陆淘宝后，假设淘宝网给你的Cookie设置的是<code>SameSite=Strict</code>，这时候你点击网站的商品准备看看详情，Oops，你又得重新登陆才可以继续进行你的操作，因为跳转的时候，淘宝的Cookie是不会附带到请求上去的。</p><ol start="2"><li>Lax</li></ol><p><code>Lax</code>的要求则没有这么严格，但是大部分情况下它也是不发送Cookie的，除非是一些导航到目标网址的<code>GET</code>请求。这里的重点是：<code>GET</code>方法，而且必须是可以造成顶级导航的<code>GET</code>方法，只有这样，<code>Lax</code>的Cookie才会被发送。</p><p>关于什么是“造成顶级导航”，这里解释一下。资源可以通过<code>img</code>、<code>iframe</code>、<code>script</code>标签进行加载，这些都可以通过<code>GET</code>请求来获取，但是它们都不会造成顶级的导航改变。基本上，它们不会更改地址栏中的URL，所以它们发出的请求，都不会带上<code>Lax</code>的Cookie。可以参考下面的表格：</p><table tabindex="0"><thead><tr><th>请求类型</th><th style="text-align:center;">示例代码</th><th style="text-align:right;">发送的Cookie</th></tr></thead><tbody><tr><td>Link</td><td style="text-align:center;"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td style="text-align:right;">Normal, Lax</td></tr><tr><td>Perender</td><td style="text-align:center;"><code>&lt;link rel=&quot;prerender&quot; href=&quot;..&quot;/&gt;</code></td><td style="text-align:right;">Normal, Lax</td></tr><tr><td>Form GET</td><td style="text-align:center;"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td style="text-align:right;">Normal, Lax</td></tr><tr><td>Form POST</td><td style="text-align:center;"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td style="text-align:right;">Normal</td></tr><tr><td>iframe</td><td style="text-align:center;"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td style="text-align:right;">Normal</td></tr><tr><td>AJAX</td><td style="text-align:center;"><code>$.get(&quot;...&quot;)</code></td><td style="text-align:right;">Normal</td></tr><tr><td>Image</td><td style="text-align:center;"><code>&lt;img src=&quot;...&quot;&gt;</code></td><td style="text-align:right;">Normal</td></tr></tbody></table><ol start="3"><li>None</li></ol><p>浏览器会在同站请求、跨站请求下继续发送cookie。不过最近由谷歌发出的提议，如果Cookie的<code>SameSite=None</code>，那么它必须包含<code>Secure</code>标记，比如：</p><div class="language-yml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">widget_session=abc123; SameSite=None // 这是一个无效的Cookie</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">widget_session=abc123; SameSite=None; Secure // 有效</span></span></code></pre></div><h2 id="cookie的限制" tabindex="-1">Cookie的限制 <a class="header-anchor" href="#cookie的限制" aria-label="Permalink to &quot;Cookie的限制&quot;">​</a></h2><p>Cookie的限制主要体现在以下几点：</p><ul><li>需要满足<code>domain</code>和<code>path</code>的作用域约束</li><li>每个域的cookie的总数是有限制的，不同浏览器肯可能限制大小有所不同</li><li>浏览器对cookie的大小也有限制，不同浏览器的上限也不同</li></ul><p>Cookie最早是用来作为客户端存储的一种手段的，但是随着<a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noreferrer"><code>Storage</code>API</a>的兴起，我们已经不需要它来承担存储性的工作了。</p><h3 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noreferrer">HTTP Headers：Set-Cookie - MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noreferrer">Cookies - MDN</a></li><li><a href="https://web.dev/samesite-cookies-explained/" target="_blank" rel="noreferrer">SameSite cookies explained</a></li><li><a href="https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/" target="_blank" rel="noreferrer">Using the Same-Site Cookie Attribute to Prevent CSRF Attacks</a></li></ul>`,52)]))}const m=t(l,[["render",d]]);export{g as __pageData,m as default};
